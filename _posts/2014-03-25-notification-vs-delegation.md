---
layout: post
title:  "Notification vs Delegation"
date:   2014-03-25
categories: Programming
---

When designing an Objective-C OS X or iOS app using the MVCS design pattern, developers must decide whether to implement delegation or register for notifications to track changes to their data store. Ideally, your app will be using Core Data, in which case you can use NSArrayController on OS X and NSFetchedResultsController on iOS. Both of these classes manage the results of a fetch request and update their content (or results) array accordingly. These classes do this by registering for notifications a NSManagedContext sends when -processPendingChanges is called. While this method is continually called for apps linking against Cocoa, on Cocoa Touch this method has to be called manually. For MVCS apps that connect to an internet service, this approach may sound simple enough: download data, cache data with Core Data, and view controllers that are observing for changes will automatically update their views. Most source code I’ve encountered works like and should work like this. But what about when the user changes the content? That is the crucial moment in designing an Objective-C app. The developer must decide whether to use delegation or register for notifications. Lots of small iPhone apps go for delegation. At the moment that may seem as a great idea, especially with a drill-down table view based interface. Since only one view controller is visible at any time, if the user changes content in say, a modal view, that creates a new entity, it can just tell the the view controller that called it through delegation that it modified its data. Seems like an ideal solution no? The issue is that first, the developer has to create an entire protocol for each view controller that will modify data and dismiss a modal VC or pop a VC in the navigation stack, second, the VCs are hardwired to work a certain way, thus reducing portability, and third (which is associated with the second issue), that code makes universal iOS development harder. While on an iPhone app it may make sense for a modal view controller to tell its delegate (the view controller that presented it) that it has modified the data in the Store, on an iPad app you might have multiple view controllers visible in a split view controller or another VC container rather than a navigation or tab bar controller. Now the developer might have to introduce “if” statements to check whether the device is iPad or not and hardwire say, a when a VC is presented modally versus when it is in a split view controller. With notifications all of these problems go away. Your view controllers are not tied to each other, only to the data store they’re getting their data from. A custom protocol does not have to be created to each VC that modifies the data or creates a new entity. Best of all, the code is portable. The developer doesn’t have to worry whether the VC was called on iPad or iPhone, nor worry about which VC presented it or which view controller it may present or push that could modify data down the navigation stack. There are times when delegation is necessary and should be used. But when working with Store classes in the MVCS architecture, especially when using Core Data, make sure that your controller registers for changes in data store so it can update its views accordingly no matter where or how they are presented to the user.
